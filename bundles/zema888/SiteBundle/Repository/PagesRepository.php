<?php

namespace SiteBundle\Repository;

use Gedmo\Tree\Entity\Repository\NestedTreeRepository;
use SiteBundle\Entity\Pages;
use Doctrine\ORM\Tools\Pagination\Paginator;

/**
 * PagesRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PagesRepository extends NestedTreeRepository
{
    /**
     * @return int
     * @throws \Doctrine\ORM\NoResultException
     * @throws \Doctrine\ORM\NonUniqueResultException
     */
    public function getMaxId()
    {
        $qb = $this->createQueryBuilder('p');
        $qb->select('MAX(p.id) as idMax');
        $result = $qb->getQuery()->getSingleResult();
        return !empty($result['idMax']) ? (int)$result['idMax'] :  0;
    }

    /**
     * пока хардкором
     */
    const MAIN_PAGE_ID = 1;

    /**
     * Массив для роутинга
     *
     * @param int $minId
     * @param int $limit
     * @return array
     * @throws \Doctrine\DBAL\DBALException
     */
    public function getRouteArray($minId = 0, $limit = 100)
    {
        $em = $this->getEntityManager();
        $sql = "SELECT
                      `path`, `discr`, `route`
                    FROM `pages`
                    WHERE `id` > " . $minId . " AND `active` = 1
                    ORDER BY `pages`.`id`
                    LIMIT " . $limit;
        $stmt = $em->getConnection()->prepare($sql);
        $stmt->execute();
        $pages = $stmt->fetchAllAssociative();

        $result = [];

        foreach ($pages as $page) {
            if (!empty(Pages::$controllers[$page['discr']])) {
                $result[] = [
                    'path' => $page['path'],
                    'route' => $page['route'],
                    'controller' => Pages::$controllers[$page['discr']]
                ];
            }
        }
        return  $result;
    }

    /**
     * Проверка есть ли пустые роуты
     *
     * @return bool
     * @throws \Doctrine\DBAL\DBALException
     */
    public function checkEmptyRoute()
    {
        $em = $this->getEntityManager();
        $sql = "SELECT COUNT(*) as `cnt`
                FROM `pages`
                WHERE `active` = 1
                AND (`route` IS NULL OR `route` = \"\" OR `path` IS NULL OR `path` = '')";
        $stmt = $em->getConnection()->prepare($sql);
        $stmt->execute();
        $result =  $stmt->fetch();
        return isset($result['cnt']) ? $result['cnt'] > 0 : false;
    }

    /**
     * обновить все роуты и пути и активность у всех страниц
     *
     * @param bool $deactivite
     * @throws \Doctrine\DBAL\DBALException
     * @throws \Doctrine\ORM\ORMException
     * @throws \Doctrine\ORM\OptimisticLockException
     */
    public function updateAllPathRoute($deactivite = true)
    {
        try {
            $em = $this->getEntityManager();
            // Все роуты страниц неактивными
            $sql = "UPDATE `pages` SET `router_active` = `active`";
            $stmt = $em->getConnection()->prepare($sql);
            $stmt->execute();
            $stmt->closeCursor();
            if ($deactivite) {
                $sql = "UPDATE `pages` SET `active` = 0 WHERE `id` !=" . self::MAIN_PAGE_ID
                    . " AND `discr` NOT IN('" . implode("','", Pages::methodNonDeleteDiscr()) . "')";
                $stmt = $em->getConnection()->prepare($sql);
                $stmt->execute();
                $stmt->closeCursor();
            }
            $sql = "UPDATE `pages` SET `active` = 1, `router_active` = 1 WHERE `discr` IN('" . implode("','", Pages::methodNonDeleteDiscr()) . "')";
            $stmt = $em->getConnection()->prepare($sql);
            $stmt->execute();
            $stmt->closeCursor();

            $this->updateChildren(self::MAIN_PAGE_ID);
        } catch (\Throwable $e) {
            $this->activateAll();
        }
    }

    /**
     * TODO перехватить ошибки
     * обновить роуты,пути,активность у детей страницы с ИД = $parentId
     *
     * @param $parentId
     * @throws \Doctrine\ORM\ORMException
     * @throws \Doctrine\ORM\OptimisticLockException
     */
    protected function updateChildren($parentId)
    {
        $em = $this->getEntityManager();
        /** @var Pages $parent */
        $parent = $this->find($parentId);
        if ($parent->getActive()) {
            $children = $this->findBy(['parentId' => $parentId, 'routerActive' => 1]);
            $route = $parent->getRoute();
            $path = $parentId == self::MAIN_PAGE_ID ? '' : $parent->getPath();
            $ids = [];
            $sql = '';
            /** @var Pages $child */
            foreach ($children as $child) {
                $sql .= "UPDATE `pages` 
                        SET `active` = 1, 
                            `route` =  '" . ($route . "_" . $child->getSlug()) . "',
                            `path` =  '" . ($path  . "/" .  $child->getSlug()) . "'
                        WHERE `id` =" . $child->getId().";";
                $ids[] = $child->getId();
            }
            if ($sql) {
                $stmt = $em->getConnection()->prepare($sql);
                $stmt->execute();
                $stmt->closeCursor();
            }
            $em->getUnitOfWork()->clear();

            foreach ($ids as $id) {
                $this->updateChildren($id);
            }
        }
    }

    public function activateAll()
    {
        $em = $this->getEntityManager();
        $sql = "UPDATE `pages` 
                        SET `active` = 1, 
                            `router_active` =  1";
        $stmt = $em->getConnection()->prepare($sql);
        $stmt->execute();
    }


    /**
     * Проверят если ли страница соответвующая пути
     *
     * @param $path
     * @return null| Pages
     */
    public function checkPageByPath($path)
    {
        $slugs = explode('/', $path);
        $page = null;
        foreach ($slugs as $slug) {
            $page = $this->findOneBy(['slug' => $slug, 'active' => true]);
            if (!$page) {
                break;
            }
        }

        return $page;
    }

    /**
     * Массив для choice в админке
     * @param $discr
     * @return array
     */
    public function getListByDiscr($discr)
    {
        $collection = $this->findBy(['discr' => $discr, 'active' => true ], ['lft' => 'ASC']);
        $choices = [];
        foreach ($collection as $item) {
            $choices[$item->getMenutitle()] = $item->getId();
        }
        return $choices;
    }


    public function getNodesHierarchy($node = null, $direct = false, array $options = array(), $includeNode = false)
    {
        return parent::getNodesHierarchy($node, $direct, $options, $includeNode); // TODO: Change the autogenerated stub
    }


    public function searchText($text)
    {
        $this->_entityName = CatalogItem::class;

        $result = [];
        $result2 = [];
        if (!$text) {
            return $result;
        }
        $textArr = explode(' ', preg_replace("/\s+/ui", ' ', $text));
        $textLike = '%' . preg_replace("/\s+/ui", '%', $text) . '%';

        $result1 = $this->createQueryBuilder('p')
            ->add('where', 'p.moduleId = :moduleId  AND (p.menutitle LIKE :searchterm)')
            ->setParameters([
                'searchterm' => $textLike,
            ])
            ->setMaxResults('30')
            ->getQuery()
            ->getResult();

        if (mb_strlen($text) > 3 && array_reduce($textArr, function ($maxLen, $word){
                return mb_strlen($word) > $maxLen ? mb_strlen($word) : $maxLen;
            }, 0) > 3) {

            $words = [];

            foreach ($textArr as $key => $val) {
                if (mb_strlen($val) > 3) {
                    $words[] = $val;
                }
            }

            $words = implode(' ', $words);
            $result2 = $this->createQueryBuilder('p')
                ->add('where', 'p.moduleId = :moduleId AND MATCH_AGAINST(p.h1, p.menutitle, p.descriptionText, p.specification, :searchterm) > 0')
                ->setParameters([
                    'searchterm' => $words,
                ])
                ->orderBy("MATCH_AGAINST (p.h1, p.menutitle, p.descriptionText, p.specification, :searchterm 'IN BOOLEAN MODE')", 'desc')
                ->setMaxResults('30')
                ->getQuery()
                ->getResult();
        }
        $this->_entityName = Pages::class;
        return array_merge($result1, $result2);
    }

    public function searchTreePages($text)
    {
        $search = '%' . preg_replace("/\s+/ui", ' ', $text) . '%';
        $result = [];
        if (!$text) {
            return $result;
        }
        $result = $this->createQueryBuilder('p')
            ->add('where', 'p.menutitle LIKE :searchterm OR p.h1 LIKE :searchterm OR p.path LIKE :searchterm')
            ->setParameter('searchterm', $search)
            ->setMaxResults('30')
            ->getQuery()
            ->getResult();
        return $result;
    }
}
